# Copyright (c) 2013-2014 by California Institute of Technology
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# 3. Neither the name of the California Institute of Technology nor
#    the names of its contributors may be used to endorse or promote
#    products derived from this software without specific prior
#    written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CALTECH
# OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
# USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
# OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
"""Automata Module"""
from __future__ import absolute_import
import logging
logger = logging.getLogger(__name__)
from pprint import pformat
import networkx as nx
from tulip.transys.labeled_graphs import SystemGraph, check_value


class Automaton(SystemGraph):
    """Alternating acceptor of (in)finite trees.

    An acceptor represents an indicator function of a set.
    The set may contain trees (unary trees are words).

    From all the possible paths in the acceptor's graph,
    some correspond to elements of the set it describes,
    but others do not belong to this set.

    In order to distinguish elements that can be generated by
    the graph, but are not contained in the set,
    two attributes are used:

      - path quantification
      - acceptance condition


    Attributes
    ==========
    Besides initial nodes
    (from [`LabeledDiGraph`] - to be split and renamed),
    an [`Automaton`] has the attributes:

      - `"universal_nodes"` is a subset of nodes.
        Remaining nodes are existentially quantified.


      - `"acceptance"` that can be:

        - `"finite"`, signifying finite words or trees
        - `"Buchi"` (or `"weak Buchi"`)
        - `"coBuchi"`
        - `"generalized Buchi"`
        - `"Rabin"`
        - `"Streett"`
        - `"Muller"`
        - `"parity"`


      - `"accepting_sets"` that contains the sets of nodes defining
        the acceptance condition:

        - `set` of nodes for (weak/co-) Buchi and finite
          For co-Buchi this is the avoidance set (FG!)
        - `list` of `dict`s of `set`s of nodes for Rabin and Streett
          The keys should be: `"GF"` and `"FG!"`,
        - `list` of `set`s of nodes for Muller and generalized Buchi,
        - a 2-`tuple` of (min, max) colors for parity
          The coloring function is defined by directly annotating the nodes.

        For convenience, the above are initialized so that
        the automaton represent an empty language.
        The user is responsible for adhering to the above conventions.

        To check compliance to the above, call [`Automaton.check_sanity`].

        Deprecated: Note that by using `SubSet(automaton)` for each set,
        you can ensure consistency if more nodes are added later.
        Alternatively, write a function that checks consistency of
        each acceptance condition wrt the automaton's nodes.


      - `alphabet`: `dict` mapping symbols to domains.
        Each edge that has an existential node as source is
        labeled with either:
          - an element of `alphabet`, or
          - a formula that defines a subset of `alphabet`
        These define the invariant at the target node.


      - `directions`: Like `alphabet`, but for universal nodes.
        If `directions` is empty, then the automaton recognizes words.


      - `guards` defines the representation of edge labels and can be:

        - `"formula"` meaning that each edge is annotated with
          a Boolean formula as `str` or AST. (Typically a conjunction.)
        - `"enumeration"` meaning that each edge is annotated with a letter,
          as `set` or `dict` (closed world semantics).


    Related concepts
    ================
    Automata represent languages in a way suitable for
    testing if a given trace is a member of the language.
    The represented language is not readily accessible,
    because its generation requires solving a search problem.

    If you want to represent a language constructively,
    then use a [`KripkeStructure`] instead.
    That is equivalent to a universal Buchi acceptor
    whose nodes are all accepting.

    To represent transductions use a [`Transducer`].


    Remark
    ======
    In `ltl2dstar` documentation L denotes a "good" set.
    To avoid ambiguity, `dict`s with explicit modalities are used as labels.


    References
    ==========
    - Orna Kupferman and Moshe Vardi,
      "Safraless decision procedures", FOCS'05, pp.531--542
    - Def. 10.53, p.801, U{[BK08]
      <http://tulip-control.sourceforge.net/doc/bibliography.html#bk08>}
    - U{ltl2dstar<http://ltl2dstar.de/>} documentation


    See also
    ========
    [`TransitionSystem`], [`Transducer`]
    """

    def __init__(self, acceptance='Buchi', alphabet=None,
                 directions=None, universal_nodes=None, guards='boolean'):
        super(Automaton, self).__init__()
        if universal_nodes is None:
            universal_nodes = set()
        if alphabet is None:
            alphabet = dict()
        if directions is None:
            directions = dict()
        # init attributes
        self.universal_nodes = universal_nodes
        self.acceptance = acceptance
        self.accepting_sets = self._init_accepting_sets(acceptance)
        alphabet = alphabet
        self.alphabet = alphabet
        self.directions = directions
        # explicit is better than implicit
        self.guards = guards

    def __str__(self):
        show_node_data = (self.acceptance == 'parity')
        is_unary = (not self.directions or len(self.directions) <= 1)
        f = lambda x: pformat(x, indent=3)
        s = (
            '{hl}\n Alternating {self.acceptance} {word_tree} automaton\n'
            '{hl}\n'
            'Alphabet:\n'
            '{self.alphabet}\n\n'
            'Directions:\n'
            '{self.directions}\n\n'
            'Nodes:\n'
            '{nodes}\n\n'
            'Initial nodes:\n'
            '{init_nodes}\n\n'
            'Universal nodes:\n'
            '{universal_nodes}\n\n'
            'Existential nodes: the rest\n\n'
            'Accepting sets:\n'
            '{accepting_sets}\n\n'
            'Edges with guards:\n'
            '{edges}\n{hl}\n').format(
                hl=40 * '-',
                self=self,
                word_tree='word' if is_unary else 'tree',
                nodes=f(self.nodes(data=show_node_data)),
                init_nodes=f(self.initial_nodes),
                universal_nodes=f(self.universal_nodes),
                accepting_sets=f(self.accepting_sets),
                edges=f(self.edges(data=True)))
        return s

    def to_pydot(self):
        # TODO: initial nodes
        g = nx.MultiDiGraph()
        for u, d in self.nodes_iter(data=True):
            if u in self.universal_nodes:
                shape = 'box'
            else:
                shape = 'circle'
            if self.acceptance in {'finite', 'Buchi', 'coBuchi'}:
                peripheries = 2
            else:
                peripheries = 1
            g.add_node(u, shape=shape, peripheries=peripheries)
        for u, v, d in self.edges_iter(data=True):
            label = ', '.join(
                '{k} = {v}'.format(k=k, v=v)
                for k, v in d.iteritems()
                if k in self.directions or k in self.alphabet)
            g.add_edge(u, v, label=label)
        return nx.to_pydot(g)

    def _init_accepting_sets(self, acceptance):
        """Return a `set`, `list` or other, depending on acceptance type."""
        if acceptance in {'finite', 'Buchi', 'coBuchi', 'weak Buchi'}:
            a = set()
        elif acceptance in {'Muller', 'generalized Buchi', 'Rabin', 'Streett'}:
            a = list()
        elif acceptance == 'parity':
            a = (None, None)
        else:
            raise ValueError('unknown acceptance: {s}'.format(s=acceptance))
        return a

    def is_consistent(self):
        """Return `True` if conformant to conventions."""
        super(Automaton, self).is_consistent()
        a = self.acceptance
        s = self.accepting_sets
        f = lambda x: all(u in self for u in x)
        if a in {'finite', 'Buchi', 'coBuchi', 'weak Buchi'}:
            assert f(s)
        elif a in {'Muller', 'generalized Buchi'}:
            for x in s:
                assert f(s)
        elif a in {'Rabin', 'Streett'}:
            for x in s:
                assert len(x) == 2
                assert set(x) == {'[]<>', '<>[]!'}
                assert f(x['[]<>'])
                assert f(x['<>[]!'])
        elif a == 'parity':
            assert len(s) == 2
        else:
            raise Exception('Unknown acceptance: {a}'.format(a=a))
        for u, v, d in self.edges_iter(data=True):
            t = self.alphabet
            r = self.directions
            if u in self.universal_nodes:
                t, r = r, t
            for k, v in d.iteritems():
                if k in t:
                    check_value(v, t[k])
                assert k not in r
        return True
